# GC总结

## 1、Serial GC
>a)、年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-整理）算法

>b)、年轻代、老年代都是基于单线程回收，不能充分利用多核CPU，适合几百M堆内存的JVM

>c)、回收时会进入"Stop-The World"状态，全面暂停业务

## 2、Parallell GC
>a)、与串行GC一样：年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-整理）算法

>b)、年轻代、老年代回收都并行进行，能充分利用多核CPU，适用于多核CPU服务器上，吞吐优先的业务

>c)、回收时会进入STW状态，但因默认所有CPU内核都进行回收，停顿时间很短

##3、ConcurentMarkSweep GC：
>a)、年轻代使用并行 mark-copy（标记-复制） 算法，老年代使用 并行mark-sweep（标记-清除）算法

>b)、年轻代并行回收、老年代并发回收，尽量减少业务STW停顿时间，适用于要求降低GC停顿导致业务延迟场景

>c)、在初始标记和最终标记阶段会进入STW状态，且老年代回收后不进行整理，STW时间短

## 4、G1(Garbage-First) GC：
>a)、使用标记-整理（Mark-Compact）算法，堆不再分为年轻代和老年代，而是划分为多个可以存放对象的小块堆区域，每个区不驱动，有时可能是年轻代、有时又是老年代

>b)、以增量的方式进行回收，每次优先回收垃圾最多的那部分，适用于要求GC停顿时间可控，且内存超过16G

>c)、回收时STW时间可根据需要去配置MaxGCPauseMills参数设，默认为200ms

# 堆总结
>JVM中堆主要包含年轻代、老年代两大区域，对象一般在年轻代产生，经过一定次数的youngc后提升到老年代中；
>
>a)、当年轻代中分配速率较低，小于回收速率或持平时，系统是健康运行的
>
>b)、当年轻代中分配速率较高，持续大于回收速率时，系统是不健康的，最终应会出现OOM
>
>c)、当年轻代中分配速率较高，同时回收速率也高时两者处于持平时，系统是不健康的
>
>d)、当提升速率过高时或接近分配率时，说明年轻代设置可能偏小，需要增大；
>
